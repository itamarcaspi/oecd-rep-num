---
title: "Effective Reproduction Number: Israel vs. OECD"
author: "Itamar Caspi"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    highlight: haddock
    keep_md: no
    theme: journal
    toc: yes
    toc_depth: 4
    toc_float: yes
abstract: |
  The following code estimates the effective reproduction number $R_t$ for Israel and compares it to the distribution of other OECD countries' $R_t$.
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = TRUE,
                      echo = TRUE,
                      warning = FALSE,
                      message = FALSE)
```

## Load packages

```{r}
library(tidyverse)   # for wrangling and plotting data
library(EpiEstim)    # for estimating R_t
library(lubridate)   # for handling dates
library(tidycovid19) # for downloading ECDC data
library(countrycode) # for handling country codes
library(scales)      # for dates on the x-axis
library(hrbrthemes)  # for a nice figure theme
library(zoo)         # for rolling means
library(gghighlight) # for highlighting plots
library(patchwork)   # for combining separate ggplots
```

## Set parameters
```{r}
window  <- 7    # smoothing window (days)
mean_si <- 4.5  # mean of the serial interval
std_si  <- 3.5  # standard deviation of the serial interval
```

## Lockdown dates
```{r}
events <- 
  tribble(
    ~date, ~event,
    ymd("2020-09-18"), "Lockdown start",
    ymd("2020-10-18"), "Exit phase 1",
    ymd("2020-11-01"), "Exit phase 2",
  )
```


## Read data

Download Johns Hopkins University data using the [`{tidycovid19}`](https://joachim-gassen.github.io/tidycovid19/) package

```{r}
df_jhu <- download_jhu_csse_covid19_data(cached = TRUE) # JHU data
df_wb  <- download_wbank_data(cached = TRUE) # world bank data
```

## Process data

Generate new cases for each country

```{r}
df <- 
  df_jhu %>% 
  mutate(cases = confirmed - lag(confirmed, 1)) %>% 
  select(iso3c, date, cases)
```

## Filter OECD countries

A list with names of OECD countries

```{r}
oecd_names <- c(
  "Israel", "Austria", "Belgium", "Czech Republic",
  "Denmark", "Estonia", "Finland", "France",
  "Germany", "Greece", "Hungary", "Iceland",
  "Ireland", "Italy", "Latvia", "Luxembourg",
  "Netherlands", "Norway", "Poland", "Portugal",
  "Slovak Republic", "Slovenia", "Spain",
  "Sweden", "Switzerland", "United Kingdom",  "Canada",
  "Chile", "Mexico", "United States", "Australia",
  "Japan", "Korea", "New Zealand", "Turkey"
)
```

Transform country names to iso3c codes using the [`{countrycode}`](https://cran.r-project.org/web/packages/countrycode/countrycode.pdf) package

```{r}
oecd_iso3c <- 
  countrycode(
    oecd_names,
    origin = "country.name",
    destination = "iso3c"
  )
```

Filter OECD countries
```{r}
df_oecd <- 
  df %>% 
  filter(iso3c %in% oecd_iso3c) %>% 
  left_join(df_wb)
```


## Set smoothing window size
```{r}
obs     <- nrow(df_oecd %>% filter(iso3c == "ISR", date >= ymd("2020-03-15")))
t_start <- seq(2, obs - window + 1) 
t_end   <- t_start + window - 1 
```


## A function that estimates $R_t$

We now write a simple function that extracts $R_t$ for a given country using the [`{EpiEstim}`](https://cran.r-project.org/web/packages/EpiEstim/index.html) package
```{r}
extract_R <- function(incid, output, t_start, t_end, mean_si, std_si) {
  
  model <- 
    estimate_R(
      incid = incid, 
      method = "parametric_si",
      config = make_config(
        list(
          mean_si = mean_si,
          std_si = std_si,
          t_start = t_start,
          t_end = t_end
        )
      )
    )
  
  rep_num <- model$R[[3]]
    
  output <-cbind(output, rep_num)
  
  return(output)
}
```

## Estimate $R_t$ for OECD countries

Estimate $R_t$ for each OECD country, and ignore those for which the function throws an error (probably due to data issues).
```{r}
output <- c()

for (i in oecd_iso3c){

  incid <- 
    df_oecd %>%
    filter(
      date >= ymd("2020-03-15"),
      iso3c == i
    ) %>%
    select(date, cases) %>%
    rename(dates = date, I = cases)

  tryCatch(
  output <- extract_R(incid, output, t_start, t_end, mean_si, std_si),
  error = function(e) e
  )

}
```

## Estimate $R_t$ for Israel

Now we estimate Israel $R_t$ and add it to the output table.
```{r}
incid <- 
  df_oecd %>%
  filter(
    date >= ymd("2020-03-15"),
    iso3c == "ISR"
  ) %>%
  select(date, cases) %>%
  rename(dates = date, I = cases)

model <- 
  estimate_R(
    incid = incid, 
    method = "parametric_si",
    config = make_config(
        list(
          mean_si = mean_si,
          std_si = std_si,
          t_start = t_start,
          t_end = t_end
        )
      )
  )
  
isr_rep_num <- 
  model$R %>% 
  select(3) %>% 
  pull()
    
output <- 
  cbind(isr_rep_num, output)
```

## Calculate median and interquartile range

### R

Dataframe to tibble
```{r}
df_R <- 
  output %>% 
  as_tibble()
```

Calculate the median and 10-90 quantiles, by rows (i.e., dates)
```{r}
df_R_q <- 
  df_R %>% 
  rowwise() %>% 
  mutate(
    q50    = quantile((c_across(rep_num:V29)), probs = 0.50),
    q_up   = quantile((c_across(rep_num:V29)), probs = 0.75),
    q_down = quantile((c_across(rep_num:V29)), probs = 0.25)
  ) %>%
  select(isr_rep_num, starts_with("q")) %>% 
  ungroup() %>% 
  mutate(
    date = seq(from = ymd("2020-03-12"), by = "1 day", length.out = dim(output)[[1]])
  )
```

### Cases

Generate 7-day rolling mean of daily cases
```{r}
df_oecd_cases <- 
  df_oecd %>% 
  filter(
    population >= 1e6,
    date >= ymd("2020-03-01")
  ) %>% 
  mutate(
    dcases = rollmean(cases, 7, na.pad=TRUE, align="right"),
    dcases_pc = dcases / population * 1e6
  ) %>%
  select(iso3c, date, dcases_pc)
```

Calculate the median and 10-90 quantiles, by rows (i.e., dates)
```{r}
df_oecd_cases_q <- 
  df_oecd_cases %>% 
  pivot_wider(date, names_from = "iso3c", values_from = "dcases_pc") %>% 
  rowwise() %>% 
  mutate(
    q50    = quantile((c_across(AUS:USA)), probs = 0.50, na.rm = TRUE),
    q_up   = quantile((c_across(AUS:USA)), probs = 0.75, na.rm = TRUE),
    q_down = quantile((c_across(AUS:USA)), probs = 0.25, na.rm = TRUE)
  ) %>%
  select(date, ISR, starts_with("q")) %>% 
  ungroup()
```


## Plot of $R_t$

Store information regarding the latest values (will be used in the plot to annotate the lines.)
```{r}
last_obs <- df_R_q %>% 
  slice(dim(output)[[1]])

last_date   <- last_obs %>% pull(date)
last_oecd   <- last_obs %>% pull(q50) %>% round(2) %>% unname()
last_israel <- last_obs %>% pull(isr_rep_num) %>% round(2) %>% unname()

label_israel <- paste0("Israel\n", last_israel)
label_oecd   <- paste0("OECD\n", last_oecd)
```

Plot $R_t$
```{r}
p_R <- df_R_q %>% 
  filter(
    date >= ymd("2020-08-01")
  ) %>% 
  ggplot(aes(x = date, y = q50)) +
  geom_line(
    aes(x = date, y = q50, color = "OECD median"),
    size = 1,
    color = "#6DCD59"
  ) +
  geom_line(
    aes(x = date, y = isr_rep_num),
    color = "#3E4A89",
    size = 1,
  ) +
  geom_ribbon(
    aes(ymin = q_down, ymax = q_up),
    fill = "#6DCD59",
    alpha = 0.4
  ) +
  geom_hline(aes(yintercept = 1), color = "black", size = 0.5) +
  annotate("text", x = last_date + days(5), y = last_oecd, label = label_oecd, color = "#6DCD59", size = 3.5) +
  annotate("text", x = last_date + days(5), y = last_israel, label = label_israel, color = "#3E4A89", size = 3.5) +
  annotate("rect", xmin = last_date, xmax = last_date + days(10), ymin = -Inf, ymax = +Inf, alpha = 0.3) +
  geom_vline(data = events, aes(xintercept = date), linetype = 2) +
  geom_text(data = events, aes(x=date, y=0.5, label=event), size=3, angle=90, vjust=-0.4, hjust=0) +
  labs(
    y = expression("R"[t]),
    x = "",
    title = "Daily Effective Reproduction Number",
    subtitle = "Israel vs. OECD median and interquartile range",
    color = "",
    lty = "",
    caption = "Notes: Gray shaded area denotes the 10-days between infection and outpatiant testing.\nData source: Johns Hopkins University Center for Systems Science and Engineering."
  ) +
  scale_x_date(labels = date_format("%Y-%m-%d")) +
  theme_ipsum() +
  theme(
    legend.position="top",
    plot.caption = element_text(hjust = 0)
  ) +
  ylim(0.5,1.5) 

p_R
```

## Plot of new cases

Store information regarding the latest values (will be used in the plot to annotate the lines.)
```{r}
last_obs <- df_oecd_cases_q %>% 
  slice(dim(df_oecd_cases_q)[[1]])

last_date   <- last_obs %>% pull(date)
last_oecd   <- last_obs %>% pull(q50) %>% round(0) %>% unname()
last_israel <- last_obs %>% pull(ISR) %>% round(0) %>% unname()

label_israel <- paste0("Israel\n", last_israel)
label_oecd   <- paste0("OECD\n", last_oecd)
```

Plot daily cases
```{r}
p_cases <- df_oecd_cases_q %>% 
  filter(
    date >= ymd("2020-08-01")
  ) %>% 
  ggplot(aes(x = date, y = q50)) +
  geom_line(
    aes(x = date, y = q50, color = "OECD median"),
    size = 1,
    color = "#6DCD59"
  ) +
  geom_line(
    aes(x = date, y = ISR),
    color = "#3E4A89",
    size = 1,
  ) +
  geom_ribbon(
    aes(ymin = q_down, ymax = q_up),
    fill = "#6DCD59",
    alpha = 0.4
  ) +
  annotate("text", x = last_date + days(5), y = last_oecd, label = label_oecd, color = "#6DCD59", size = 3.5) +
  annotate("text", x = last_date + days(5), y = last_israel, label = label_israel, color = "#3E4A89", size = 3.5) +
  geom_vline(data = events, aes(xintercept = date), linetype = 2) +
  geom_text(data = events, aes(x=date, y=0.5, label=event), size=3, angle=90, vjust=-0.4, hjust=0) +
  labs(
    title = "Daily new cases",
    subtitle = "Israel vs. OECD median and interquartile range",
    y = "Daily new cases per 1 million\n(7-day moving average)",
    x = "",
    caption = "Notes: The sample is limited to countries with a population exceeding 1 million.\nData source: Johns Hopkins University Center for Systems Science and Engineering."
  ) +
  scale_x_date(labels = date_format("%Y-%m-%d")) +
  theme_ipsum() +
  theme(
    legend.position="top",
    plot.caption = element_text(hjust = 0)
  )

p_cases
```

## Plot both figures
```{r, eval = FALSE}
p_cases + p_R
```


## Save to File

Save data to a csv file.
```{r}
write_csv(df_R_q, path = "output/oecd-rep-num.csv")
write_csv(df_oecd_cases_q, path = "output/oecd-cases.csv")
```
